#!/bin/env python3
# TODO: update PIP packages
"""Updates packages from various package managers. See the definitions of
UPDATERS and EXTRA_UPDATERS below."""
import signal
from shutil import which
from typing import Optional, List, Final
import subprocess as sp
from argparse import ArgumentParser, Namespace
from dataclasses import dataclass
import sys

MIN_VERSION = (3, 8)
if sys.version_info < MIN_VERSION:
    min_version: str = f'{MIN_VERSION[0]}.{MIN_VERSION[1]}'
    actual_version: str = f'{sys.version_info[0]}.{sys.version_info[1]}'
    sys.exit(f"Need Python {min_version}! Have {actual_version}")

# Exit gracefully on keyboard interrupt
signal.signal(signal.SIGINT, signal.SIG_DFL)

@dataclass
class Format:
    """String constants for styling terminal output"""
    # pylint: disable=invalid-name
    BOLD: Final[str] = '\033[1m'
    RESET: Final[str] = '\033[0m'
    RED: Final[str] = '\033[31m'

def print_error(*args: str, end: str = '\n') -> None:
    """Concatenates arguments and prints them in bold red text"""
    print_bold(Format.RED, *args, end=end)

def print_bold(*args: str, end: str = '\n') -> None:
    """Concatenates arguments and prints them in bold"""
    print(Format.BOLD, *args, Format.RESET, sep='', end=end)


class Updater:
    # TODO: Don't really need a class here. Could just run updates immediately
    # instead of constructing objects and calling .run().
    """Defines a method to update some set of packages"""
    command: List[str]
    as_root: bool
    description: str
    fallback: Optional['Updater']

    def __init__(
        self,
        command: str,
        description: str,
        fallback: Optional['Updater'] = None,
        as_root: bool = False
    ):
        if len(command) == 0:
            raise ValueError('Empty command')

        self.description = description
        self.fallback = fallback
        self.as_root = as_root
        self.command = command.split(' ')

    def __program_exists(self) -> bool:
        """Checks whether the program that is to be run exists"""
        return which(self.command[0]) is not None

    def __fallback(self) -> None:
        """Fall back to running self.fallback"""
        if self.fallback is not None:
            self.fallback.run()

    def __run(self) -> None:
        command = self.command
        if self.as_root:
            command.insert(0, 'sudo')
        print_bold(f'Updating {self.description}...')
        sp.run(command, check=True)

    def run(self) -> None:
        """Runs the updater"""
        if not self.__program_exists():
            print_bold(Format.RED, f'Program `{self.command[0]}` not found')
            self.__fallback()
        else:
            try:
                self.__run()
            except sp.CalledProcessError as err:
                command_str: str = ' '.join(self.command)
                print_bold(Format.RED,
                    f'Command `{command_str}` failed with return code {err.returncode}')


@dataclass(frozen=True)
class Options:
    """Represents the parsed command line options"""
    extra: bool
    git: bool


def parse_args() -> Options:
    """Parses command line arguments"""
    parser: ArgumentParser = ArgumentParser(description='Update packages.')
    parser.add_argument('-e', '--extra', action='store_true',
                        default=False, help='update all packages')
    parser.add_argument('-g', '--git', action='store_true', default=False)
    parsed: Namespace = parser.parse_args(sys.argv[1:])
    return Options(extra=parsed.extra, git=parsed.git)


options: Options = parse_args()

# TODO: add npm -g outdated --parseable --depth=0 | cut -d: -f2 | xargs -r -n1 sudo npm -g install
UPDATERS: Final[List[Updater]] = [
    Updater('pacman -Syu', 'pacman packages', as_root=True),
    Updater('yay -Syua --needed' +
            (' --devel' if options.git else ''), 'aur packages'),
]

EXTRA_UPDATERS: Final[List[Updater]] = [
    Updater('pacman -Fy', 'pacman file database', as_root=True),
    Updater('nvim +:PlugUpdate +:qa', 'neovim plugins'),
    Updater('nvim +:CocUpdate +:qa', 'neovim coc extensions'),
    Updater('flatpak update -y', 'global flatpak applications', as_root=True),
    Updater('flatpak update --user -y', 'user flatpak applications'),
    Updater('cargo install-update --all' +
            (' --git' if options.git else ''), 'cargo crates'),
    Updater('rustup update', 'rust toolchains'),
]

for updater in UPDATERS:
    updater.run()

if options.extra:
    for updater in EXTRA_UPDATERS:
        updater.run()
